## 1. Введение: Роль пользовательских требований 

### 1.1. Иерархия требований (Краткое повторение)

На первой лекции мы определили, что требования существуют на разных уровнях.

1. **Бизнес-требования (БТ):** Почему мы строим систему (Vision и цели проекта).

2. **Пользовательские требования (ПТ):** Что пользователи должны иметь возможность делать с системой, чтобы достичь этих БТ.

3. **Функциональные требования (ФТ):** Как система должна себя вести для поддержки ПТ.

**Пользовательские требования (ПТ)** описывают цели или задачи, которые пользователи должны иметь возможность выполнить с помощью продукта, чтобы он принес им пользу.

### 1.2. Подход, ориентированный на использование

Мы придерживаемся **подхода, ориентированного на использование** (usage-oriented approach).

• Вместо того чтобы фокусироваться на списке функций, мы фокусируемся на понимании и исследовании задач, которые пользователи должны выполнять.

• На основе этого анализа мы выводим необходимую функциональность. Это помогает избежать создания "ненужных функций", которые казались интересными, но не приносят пользы пользователям.

• Два основных инструмента для моделирования ПТ: Варианты использования (Use Cases) и Пользовательские истории (User Stories).

## 2. Варианты использования (Use Cases): Структурированное моделирование

Варианты использования (Use Cases) — это традиционный и наиболее структурированный способ моделирования пользовательских требований, формализованный в виде подхода, использующего варианты использования продукта.

### 2.1. Определение и ключевые термины

**Вариант использования (Use Case)** — описание набора логически связанных возможных взаимодействий действующего лица и системы, которые дают результат, ценный для действующего лица.

• **Именование:** Всегда используется формат **"глагол + объект"** (например, "Заказать химикат", "Зарегистрироваться на рейс", "Обновить профиль клиента").

• **Действующее лицо (Actor):** Внешний объект (пользователь, другая система), который взаимодействует с системой и получает полезный результат. Действующее лицо инициирует вариант использования.

### 2.2. Основные компоненты (Спецификация Use Case)

Полная спецификация Use Case требует четкого определения его границ и шагов:

1. **Предварительные условия (Pre-conditions):** Условия, которые должны быть истинны до начала варианта использования. Если они не выполнены, Use Case не может начаться.

2. **Выходные условия (Post-conditions):** Состояние системы после успешного завершения Use Case.

3. **Нормальное направление (Normal Flow):** Главный сценарий успешного выполнения задачи. Представлен нумерованным списком операций, указывающим конкретные сущности (систему или действующее лицо), которые выполняют эти операции.

4. **Альтернативные направления (Alternative Flows):** Успешные сценарии, которые достигают выходного условия, но проходят другим путем.

5. **Исключения (Exceptions):** Ошибки или сбои, не позволяющие Use Case завершиться успешно (например, недоступность БД, неверный ввод данных).

**Важный принцип:** С помощью вариантов использования удается выявить большинство, но не все, функциональные требования. Но самое главное — Use Case помогает аналитику и клиенту **продумать все возможные пути** и исключения до начала проектирования.

### 2.3. Связь с функциональными требованиями и тестированием

Варианты использования являются основой для дальнейшей работы:

• **Функциональные требования (ФТ):** На основе детальной спецификации Use Case аналитик формулирует ФТ, которые разработчики должны реализовать.

• **Концептуальные тесты:** Разработка тестов на основе Use Case на ранних этапах (до кодирования) помогает проверить, действительно ли выявлены все ФТ, необходимые для выполнения задачи.

• **Дизайн:** Use Case не должен содержать деталей дизайна. Но он может быть представлен в виде **Карты диалоговых окон** (Map of Dialogues), которая наглядно показывает навигацию и ответвления (нотация для следующей лекции).

## 3. Пользовательские истории (User Stories): Гибкость и приемочные тесты (35 минут)

Пользовательские истории — это альтернативный, более краткий и гибкий способ представления ПТ, часто используемый в методологиях Agile.

### 3.1. Формат и цель

Пользовательская история — это "короткое, простое описание функции с точки зрения человека, которому нужна эта новая возможность". Она служит начальной точкой для дискуссий.

**Стандартный шаблон:** $$ \text{Как } \langle\text{тип пользователя}\rangle\text{, я хочу } \langle\text{цель}\rangle\text{, чтобы } \langle\text{причина}\rangle $$

• В отличие от простого списка функций, этот шаблон включает **обоснование (причину)**, которое помогает команде понять ценность этой возможности для бизнеса.

### 3.2. Эпики и Резерв продукта (Backlog)

• **Эпики (Epics):** Пользовательские истории, которые слишком велики для реализации в одной итерации, называются эпиками.

• **Резерв продукта (Product Backlog):** Все истории накапливаются в резерве продукта — упорядоченном по приоритетам списке требований. Истории могут быть записаны на простых карточках или в специализированных инструментах.

• **Итеративный подход:** В Agile-проектах работа над требованиями ведется часто, но небольшими объемами. Границы итераций состоят из историй, выбранных из резерва на основе приоритетов.

### 3.3. Приемочные тесты как "Условие удовлетворения"

Ключевое отличие User Story от Use Case в том, как они детализируются:

• Вместо подробной письменной спецификации, команды гибкой разработки тщательно перерабатывают пользовательскую историю в набор **Приемочных тестов (Acceptance Tests)**.

• Приемочные тесты в совокупности описывают **"условие удовлетворения"** истории.

• Если разработчик реализовал код, который проходит все приемочные тесты, история считается корректно реализованной и **принятой** Владельцем продукта (Product Owner).

**Инвестиции в тестирование:** Мышление в терминах тестирования на таком раннем этапе (как при создании приемочных тестов, так и концептуальных тестов для Use Case) помогает выявить исключительные условия и нефункциональные требования до написания кода, что значительно снижает затраты.

## 4. Заключение: Когда что использовать 

Оба метода направлены на создание "общего понимания" (единообразия понимания) между клиентами и разработчиками.

|   |   |   |
|---|---|---|
|Характеристика|Вариант использования (Use Case)|Пользовательская история (User Story)|
|**Детализация**|Высокая, структурированная.|Низкая, краткая ("обещание разговора").|
|**Фокус**|Потоки диалогов, все пути (нормальные, альтернативные, исключения).|Цель пользователя и бизнес-обоснование (why).|
|**Подходит для**|Сложных приложений, систем с высокими рисками, где критичен полный охват всех сбоев.|Гибкой разработки, динамического резерва, частой приоритизации.|

